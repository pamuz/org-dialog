# -*- eval: (org-dialog-mode 1); -*-

#+TITLE: org-dialog
#+PROPERTY: header-args:emacs-lisp :tangle org-dialog.el :padline yes :lexical t
#+DIALOG_MODEL: gpt-5.2-chat
#+DIALOG_ENDPOINT: https://pablo-ml1b1csr-eastus2.cognitiveservices.azure.com/openai/v1/chat/completions
#+DIALOG_API_KEY: INFERENCE_API_KEY
#+DIALOG_SYSTEM: You are co-authoring an org mode file with me. Please respond only with utf8 characters. No em-dashes. No sleek arrows. You always reply in a dry concise manner. As short as possible.

* Introduction
In order to have literate tests of the code in this project, since
some of the code operates in a buffer, we use =with-temp-buffer= to
simulate that.

* Scaffolding
#+begin_src emacs-lisp
  ;;; org-dialog.el --- Introduces executable PROMPT org blocks in org-mode -*- lexical-binding: t; -*-
  ;; Author: Pablo
  ;; Version: 0.1.0
  ;; Package-Requires: ((emacs "27.1") (org "9.0"))

  ;;; Code:
  (require 'org)
  (require 'org-element)
  (require 'json)
  (require 'url)
#+end_src

* Chopping an org buffer into a collection of prose, prompt and assistant chunks
#+begin_src emacs-lisp
    (defun org-dialog--parse-chunks (pos)
      "Parse dialogue blocks from buffer start to POS.
    Returns ordered list of (TYPE . CONTENT) where TYPE is
    `prose', `prompt', or `assistant'."
      (save-excursion
        (goto-char (point-min))
        (let ((result nil)
              (prose-start (point-min))
              (case-fold-search t))
          (while (and ( <= (point) pos)
  		(re-search-forward
                  "^[ \t]*#\\+begin_\\(prompt\\|assistant\\)" pos t))
            (let* ((block-type (downcase (match-string 1)))
                   (begin-line-start (line-beginning-position)))
              ;; Prose before this block
              (when (< prose-start begin-line-start)
                (let ((prose (string-trim
                              (buffer-substring-no-properties
                               prose-start begin-line-start))))
                  (when (> (length prose) 0)
                    (push (cons 'prose prose) result))))
              ;; Content starts on the next line
              (forward-line 1)
              (let ((content-start (point)))
                (if (re-search-forward
                     (format "^[ \t]*#\\+end_%s" block-type) pos t)
                    (let ((content-end (line-beginning-position)))
                      (let ((content (string-trim
                                      (buffer-substring-no-properties
                                       content-start content-end))))
                        (when (> (length content) 0)
                          (push (cons (intern block-type) content) result)))
                      ;; Next prose starts after end line
                      (forward-line 1)
                      (setq prose-start (point)))
                  ;; No matching end found, skip
                  (setq prose-start content-start)))))
          (nreverse result))))
#+end_src

#+begin_src emacs-lisp :tangle no :wrap example :results value pp
    (with-temp-buffer
      (insert "#+TITLE: An example user of org-dialog
  This is an example collaboration between human and AI to author an .org
  document together.

  Interpersed within the prose of the document the human can write
  =#+begin_prompt= blocks, with some prompt to AI inside.

  The human then positions the pointer somewhere within the block and
  executes keychord ctrl-c ctrl-c, this sends the prompts to an AI, parses
  the AI's response and puts the response right after the prompt block,
  within a =#+begin_assistant= block.

  ,* Conversation

  ,#+begin_prompt
  What is 2 + 2?
  ,#+end_prompt

  ,#+begin_assistant
  2 + 2 = 4
  ,#+end_assistant

  ,#+begin_src python
  def add(a, b):
      return a + b
  ,#+end_src

  ,#+begin_prompt
  Multiply that by 5
  ,#+end_prompt")
      (org-dialog--parse-chunks (point-max)))
#+end_src

#+RESULTS:
#+begin_example
((prose
  . "#+TITLE: An example user of org-dialog\nThis is an example collaboration between human and AI to author an .org\ndocument together.\n\nInterpersed within the prose of the document the human can write\n=#+begin_prompt= blocks, with some prompt to AI inside.\n\nThe human then positions the pointer somewhere within the block and\nexecutes keychord ctrl-c ctrl-c, this sends the prompts to an AI, parses\nthe AI's response and puts the response right after the prompt block,\nwithin a =#+begin_assistant= block.\n\n* Conversation")
 (prompt . "What is 2 + 2?") (assistant . "2 + 2 = 4")
 (prose
  . "#+begin_src python\ndef add(a, b):\n    return a + b\n#+end_src")
 (prompt . "Multiply that by 5"))
#+end_example

* Preparing LLM request
#+begin_src emacs-lisp
  (defun org-dialog--blocks-to-messages (blocks config)
    "Converts BLOCKS to OpenAI messages array.
  CONFIG is a plist with :system."
    (let ((messages nil)
  	(system (plist-get config :system)))
      (when system
        (push `((role . "system") (content . ,system)) messages))
      (dolist (block blocks)
        (let ((type (car block))
  	    (content (cdr block)))
  	(push `((role . ,(if (eq type 'assistant) "assistant" "user"))
  		(content . ,content))
  	      messages)))
      (nreverse messages)))
#+end_src

Example:

#+begin_src emacs-lisp :tangle no :wrap example :results value pp
  (let ((blocks '((prose . "This is an example collaboration between human and AI to author an .org\ndocument together.\n\nInterpersed within the prose of the document the human can write\n=#+begin_prompt= blocks, with some prompt to AI inside.\n\nThe human then positions the pointer somewhere within the block and\nexecutes keychord ctrl-c ctrl-c, this sends the prompts to an AI, parses\nthe AI's response and puts the response right after the prompt block,\nwithin a =#+begin_assistant= block.")
                  (prompt . "What is 2 + 2?")
                  (assistant . "2 + 2 = 4")
                  (prose . "```python\ndef add(a, b):\n    return a + b\n```")
                  (prompt . "Multiply that by 5"))))
    (org-dialog--blocks-to-messages blocks '(:system "You are a helpful assistant.")))
#+end_src

#+RESULTS:
#+begin_example
(((role . "system") (content . "You are a helpful assistant."))
 ((role . "user")
  (content
   . "This is an example collaboration between human and AI to author an .org\ndocument together.\n\nInterpersed within the prose of the document the human can write\n=#+begin_prompt= blocks, with some prompt to AI inside.\n\nThe human then positions the pointer somewhere within the block and\nexecutes keychord ctrl-c ctrl-c, this sends the prompts to an AI, parses\nthe AI's response and puts the response right after the prompt block,\nwithin a =#+begin_assistant= block."))
 ((role . "user") (content . "What is 2 + 2?"))
 ((role . "assistant") (content . "2 + 2 = 4"))
 ((role . "user")
  (content . "```python\ndef add(a, b):\n    return a + b\n```"))
 ((role . "user") (content . "Multiply that by 5")))
#+end_example

* ASSISTANT blocks
** Writing an assitant block for a prompt block
#+begin_src emacs-lisp
  (defun org-dialog--write-assistant-block (content)
    "Write some content inside an ASSISTANT block, right after a PROMPT block.
  If an ASSISTANT block already exists it is replaced."
    (let ((bounds (org-dialog--in-prompt-p)))
      (unless bounds
        (user-error "Not inside a #+BEGIN_PROMPT block"))
      (save-excursion
        (goto-char (cdr bounds))
        (let ((case-fold-search t)
  	    (insert-at nil))
  	;; Check for existing assistant block immediately after.
  	(save-excursion
  	  (forward-line 1)
  	  (skip-chars-forward " \t\n")
  	  (when (looking-at "^[\t]*#\\+begin_assistant")
  	    (setq insert-at (point))))
  	(if insert-at
  	    ;; replace content of existing assistant block
  	    (progn
  	      (goto-char insert-at)
  	      (forward-line 1)
  	      (let ((content-start (point)))
  		(re-search-forward "^[\t]*#\\+end_assistant")
  		(delete-region content-start (line-beginning-position))
  		(goto-char content-start)
  		(insert (org-dialog--escape-org content) "\n")))
  	  (goto-char (cdr bounds))
  	  (end-of-line)
  	  (insert "\n\n#+begin_assistant\n"
  		  (org-dialog--escape-org content)
  		  "\n#+end_assistant"))))
      (org-dialog--apply-overlays)))
#+end_src

Example:

#+begin_src emacs-lisp :tangle no :wrap example :results output
    (with-temp-buffer
      (org-mode)
      (org-dialog-mode 1)
      (insert "# An example org dialog buffer
    Some introductory text.

    ,#+begin_prompt
    What is literate programming?
    ,#+end_prompt")
      (forward-line -1)
      (org-dialog--write-assistant-block "An old but powerful coding technique")
      (princ (buffer-string)))
#+end_src

#+RESULTS:
#+begin_example
# An example org dialog buffer
Some introductory text.

,#+begin_prompt
What is literate programming?
,#+end_prompt

,#+begin_assistant
An old but powerful coding technique
,#+end_assistant
#+end_example

* Execute inference
#+begin_src emacs-lisp
  (defun org-dialog--infer (messages config callback error-callback)
    "Send MESSAGES to a Chat Completions endpoint.
  CONFIG is a plist with :endpoint :api-key :model.
  CALLBACK receives the response text.
  ERROR-CALLBACK receives an error string."
    (let* ((endpoint (plist-get config :endpoint))
           (api-key  (plist-get config :api-key))
           (model    (plist-get config :model))
           (url-request-method "POST")
           (url-request-extra-headers
            `(("Content-Type"  . "application/json")
              ("Authorization" . ,(concat "Bearer " api-key))))
           (url-request-data
            (encode-coding-string
             (json-serialize `((model . ,model)
                               (messages . ,(vconcat messages))))
             'utf-8)))
      (url-retrieve
       endpoint
       (lambda (status cb err-cb)
         (if (or (plist-get status :error)
                 (null url-http-end-of-headers))
             (funcall err-cb
                      (format "HTTP error: %s"
                              (or (plist-get status :error) "no response headers")))
           (goto-char url-http-end-of-headers)
           (condition-case e
               (let* ((json-object-type 'alist)
                      (json-array-type  'vector)
                      (resp (json-read))
                      (choices (alist-get 'choices resp))
                      (text (and choices
                                 (> (length choices) 0)
                                 (alist-get 'content
                                            (alist-get 'message
                                                       (aref choices 0))))))
                 (if text
                     (funcall cb text resp)
                   (funcall err-cb
                            (format "No content in response: %s"
                                    (buffer-substring (point) (point-max))))))
             (error
              (funcall err-cb
                       (format "JSON parse error: %s" e))))))
       (list callback error-callback) t)))
#+end_src

Sanity check - hits the endpoint synchronously:

#+begin_src emacs-lisp :tangle no :wrap example :results value pp :tangle no
  (let* ((url-request-method "POST")
         (url-request-extra-headers
          `(("Content-Type"  . "application/json")
            ("Authorization" . ,(concat "Bearer " (getenv "INFERENCE_API_KEY")))))
         (url-request-data
          (encode-coding-string
           (json-encode
            `((model . "gpt-5.2-chat")
              (messages . [((role . "user") (content . "What is 2 + 2?"))])))
           'utf-8))
         (buf (url-retrieve-synchronously
  	     "https://pablo-ml1b1csr-eastus2.cognitiveservices.azure.com/openai/v1/chat/completions")))
    (with-current-buffer buf
      (goto-char url-http-end-of-headers)
      (let* ((json-object-type 'alist)
             (json-array-type 'vector)
             (resp (json-read)))
        resp)))
#+end_src

#+RESULTS:
#+begin_example
((choices
  . [((content_filter_results
       (hate (filtered . :json-false) (severity . "safe"))
       (protected_material_code (filtered . :json-false)
				(detected . :json-false))
       (protected_material_text (filtered . :json-false)
				(detected . :json-false))
       (self_harm (filtered . :json-false) (severity . "safe"))
       (sexual (filtered . :json-false) (severity . "safe"))
       (violence (filtered . :json-false) (severity . "safe")))
      (finish_reason . "stop") (index . 0) (logprobs)
      (message (annotations . []) (content . "2 + 2 = **4**.")
	       (refusal) (role . "assistant")))])
 (created . 1770494705)
 (id . "chatcmpl-D6iq9PJjUpjckDcJ2bN4WmUWfVFNS")
 (model . "gpt-5.2-chat-2025-12-11") (object . "chat.completion")
 (prompt_filter_results
  . [((prompt_index . 0)
      (content_filter_results
       (hate (filtered . :json-false) (severity . "safe"))
       (jailbreak (filtered . :json-false) (detected . :json-false))
       (self_harm (filtered . :json-false) (severity . "safe"))
       (sexual (filtered . :json-false) (severity . "safe"))
       (violence (filtered . :json-false) (severity . "safe"))))])
 (system_fingerprint)
 (usage (completion_tokens . 19)
	(completion_tokens_details (accepted_prediction_tokens . 0)
				   (audio_tokens . 0)
				   (reasoning_tokens . 0)
				   (rejected_prediction_tokens . 0))
	(prompt_tokens . 14)
	(prompt_tokens_details (audio_tokens . 0) (cached_tokens . 0))
	(total_tokens . 33)))
#+end_example

* Escape org syntax in assistant responses
#+begin_src emacs-lisp
  (defun org-dialog--escape-org (text)
    "Comma-escape lines in TEXT that org would interpret as structure.
  Escapes lines starting with `*' (headings) or `#+' (keywords/blocks)."
    (replace-regexp-in-string
     "^\\(\\*\\|#\\+\\)" ",\\1" text))
#+end_src

* Pretty-print JSON
#+begin_src emacs-lisp
  (defun org-dialog--pp-json (obj)
    "Return OBJ as a pretty-printed JSON string."
    (let ((json-encoding-pretty-print t))
      (json-encode obj)))
#+end_src

* Execute a PROMPT block
#+begin_src emacs-lisp
  (defun org-dialog-execute ()
    "Send the current prompt block to inference endpoint and insert the response."
    (interactive)
    (let ((bounds (org-dialog--in-prompt-p)))
      (unless bounds
        (user-error "Not inside a #+BEGIN_PROMPT block"))
      (let* ((prompt-end (cdr bounds))
  	   (params (org-dialog--prompt-params))
  	   (debug-p (and params (string-match-p ":debug" params)))
  	   (config (org-dialog--config))
  	   (blocks (org-dialog--parse-chunks prompt-end))
  	   (messages (org-dialog--blocks-to-messages blocks config))
  	   (buf (current-buffer))
  	   (inhibit-read-only t))
        ;; Set read-only
        (setq buffer-read-only t)
        (message "org-dialog: inferring...")
        (funcall #'org-dialog--infer
  	       messages config
  	       (lambda (text resp)
  		 (with-current-buffer buf
  		   (let* ((inhibit-read-only t)
  			  (output
  			   (if debug-p
  			       (concat text
  				       "\n\n--- Request ---\n"
  				       (org-dialog--pp-json
  					`((model . ,(plist-get config :model))
  					  (messages . ,(vconcat messages))))
  				       "\n\n--- Response ---\n"
  				       (org-dialog--pp-json resp))
  			     text)))
  		     (org-dialog--write-assistant-block output)
  		     (setq buffer-read-only nil))))
  	       ;; Error callback
  	       (lambda (err)
  		 (with-current-buffer buf
  		   (let ((inhibit-read-only t))
  		     (setq buffer-read-only nil))
  		   (org-dialog--write-assistant-block err)))))))
#+end_src

* Utilities
** Get settings from org file header
#+begin_src emacs-lisp
  ;;; Config
  (defun org-dialog--keyword (key)
    "Read a #+KEY: value from the current org buffer."
    (cadr (assoc key (org-collect-keywords (list key)))))
#+end_src

Example - can retrieve the model.

#+begin_src emacs-lisp :tangle no :wrap example :results value pp 
  (with-temp-buffer
    (insert "#+TITLE: An org dialog file\n#+DIALOG_MODEL: gpt-5.2-chat")
    (org-dialog--keyword "DIALOG_MODEL"))
#+end_src

#+RESULTS:
#+begin_example
"gpt-5.2-chat"
#+end_example

** Gather all settings
#+begin_src emacs-lisp
  (defun org-dialog--config ()
    "Compose dialog config from buffer keywords.
  Returns plist (:model :endpoint :api-key :system)."
    (let* ((model (org-dialog--keyword "DIALOG_MODEL"))
  	 (endpoint (org-dialog--keyword "DIALOG_ENDPOINT"))
  	 (api-key-env (org-dialog--keyword "DIALOG_API_KEY"))
  	 (api-key (getenv api-key-env))
  	 (system (org-dialog--keyword "DIALOG_SYSTEM")))
      (unless model (user-error "No #+DIALOG_MODEL: set"))
      (unless endpoint (user-error "No #+DIALOG_ENDPOINT: set"))
      (unless api-key (user-error "No #+DIALOG_API_KEY: set"))

      (list :model model :endpoint endpoint :api-key api-key :system system)))
#+end_src

Example -- all settings read and returned.

#+begin_src emacs-lisp :tangle no :wrap example :results value pp
  (with-temp-buffer
    (org-mode)
    (setq-local process-environment (cons "MY_API_KEY=abc123" process-environment))
    (insert "#+TITLE: An example org dialog
  ,#+DIALOG_MODEL: gpt-5.2-chat
  ,#+DIALOG_ENDPOINT: https://foo.bar/v1/completions
  ,#+DIALOG_API_KEY: MY_API_KEY
  ,#+DIALOG_SYSTEM: You are a helpful assistant co-writing an org mode file with me

  ,* Introduction
  The goal of this dialog is to...
  ")
    (org-dialog--config))
#+end_src

#+RESULTS:
#+begin_example
  (:model "gpt-5.2-chat"
   :endpoint "https://foo.bar/v1/completions"
   :api-key "abc123"
   :system "You are a helpful assistant co-writing an org mode file with me")
#+end_example

** Detect if pointer on prompt block
#+begin_src emacs-lisp
  ;;; Block detection
  (defun org-dialog--in-prompt-p ()
      "Return (BEG . END) if point is inside a #+begin_prompt block, nil otherwise.
  BEG is the start of #+begin_prompt line, END is the end of #+end_prompt line."
    (save-excursion
      (let ((pos (point))
  	  (case-fold-search t))
        (when (re-search-backward "^[ \t]*#\\+begin_prompt" nil t)
  	(let ((beg (line-beginning-position)))
  	  (when (re-search-forward "^[ \t]*#\\+end_prompt" nil t)
  	    (let ((end (line-end-position)))
  	      (when ( <= pos end)
  		(cons beg end)))))))))
#+end_src

Example - can detect whether point is at a prompt block or not:

#+begin_src emacs-lisp :tangle no :wrap example :results output
    (with-temp-buffer
      (org-mode)
      (insert "* A heading
  ,#+begin_prompt
  How old is earth
  ,#+end_prompt")
      (princ (format "In prompt: %s\n" (org-dialog--in-prompt-p)))
      (insert "
  Some more different text")
      (princ (format "In prompt: %s" (org-dialog--in-prompt-p))))
#+end_src

#+RESULTS:
#+begin_example
In prompt: (13 . 57)
In prompt: nil
#+end_example

** Parse prompt block parameters
Extracts the text after =#+begin_prompt= on the same line. Used to
detect per-block settings like =:debug=.

#+begin_src emacs-lisp
  (defun org-dialog--prompt-params ()
    "Parse parameter string from the #+begin_prompt line containing point.
  Returns the trimmed parameter string, or nil if none."
    (save-excursion
      (let ((case-fold-search t))
        (when (re-search-backward "^[ \t]*#\\+begin_prompt\\(.*\\)" nil t)
          (let ((params (string-trim (match-string 1))))
            (when (> (length params) 0)
              params))))))
#+end_src

Example - detects =:debug= on the prompt line:

#+begin_src emacs-lisp :tangle no :wrap example :results output
    (with-temp-buffer
      (org-mode)
      (insert "#+begin_prompt :debug\nWhat is 2+2?\n#+end_prompt")
      (goto-char 30)
      (princ (format "Params: %s\n" (org-dialog--prompt-params))))
#+end_src

* User experience Look and feel
** Different color for assisant block content
#+begin_src emacs-lisp
(defface org-dialog-assistant
  '((((background dark))
     :foreground "#88c0d0" :slant italic :extend t)
    (((background light))
     :foreground "#3465a4" :slant italic :extend t))
  "Face for assistant block content."
  :group 'org-dialog)
#+end_src

** Apply overlays (face, indent)
#+begin_src emacs-lisp
(defun org-dialog--apply-overlays ()
  "Apply face overlays to all assistant block contents in the buffer."
  (remove-overlays (point-min) (point-max) 'org-dialog-assistant t)
  (save-excursion
    (goto-char (point-min))
    (let ((case-fold-search t))
      (while (re-search-forward "^[ \t]*#\\+BEGIN_ASSISTANT" nil t)
        (let ((content-start (progn (forward-line 1) (point))))
          (when (re-search-forward "^[ \t]*#\\+END_ASSISTANT" nil t)
            (let* ((content-end (line-beginning-position))
                   (ov (make-overlay content-start content-end nil t nil)))
              (overlay-put ov 'org-dialog-assistant t)
              (overlay-put ov 'face 'org-dialog-assistant)
              (overlay-put ov 'line-prefix "  ")
              (overlay-put ov 'wrap-prefix "  "))))))))
#+end_src

** Keybindings
#+begin_src emacs-lisp
;;; C-c C-c hook

(defun org-dialog--ctrl-c-ctrl-c ()
  "Hook for `org-ctrl-c-ctrl-c-hook'.
If point is inside a prompt block, execute it and return t."
  (when (org-dialog--in-prompt-p)
    (org-dialog-execute)
    t))
#+end_src

* Footer
#+begin_src emacs-lisp
  ;;; Minor mode

  ;;;###autoload
  (define-minor-mode org-dialog-mode
    "Minor mode for LLM dialog notebooks in org-mode.
  Intercepts C-c C-c inside #+BEGIN_PROMPT blocks to send
  conversation history to an LLM and insert the response."
    :lighter " Dia"
    :group 'org-dialog
    (if org-dialog-mode
        (progn
          (add-hook 'org-ctrl-c-ctrl-c-hook
                    #'org-dialog--ctrl-c-ctrl-c nil t)
          (org-dialog--apply-overlays))
      (remove-hook 'org-ctrl-c-ctrl-c-hook
                   #'org-dialog--ctrl-c-ctrl-c t)
      (remove-overlays (point-min) (point-max) 'org-dialog-assistant t)))

    (provide 'org-dialog)
    ;;; org-dialog.el ends here
#+end_src

* Exploration

#+begin_prompt
What do you think of this project?
#+end_prompt

#+begin_assistant
Solid design. Clear scope. Pragmatic org integration. Parsing and UX
are sensible. Network layer is minimal but adequate. Needs tests and
error hardening.
#+end_assistant

#+begin_prompt
So far I'm making this project work by having a gpt-5.2-chat model
deployed in azure foundry that I route requests to. Could I make it
work with litellm docker image?
#+end_prompt
