# -*- eval: (org-dialog-mode 1); -*-

#+TITLE: org-dialog
#+PROPERTY: header-args:emacs-lisp :tangle org-dialog.el :padline yes :lexical t
#+DIALOG_MODEL: gpt-5.2-chat
#+DIALOG_ENDPOINT: https://pablo-ml1b1csr-eastus2.cognitiveservices.azure.com/openai/v1/chat/completions
#+DIALOG_API_KEY: INFERENCE_API_KEY
#+DIALOG_SYSTEM: You are co-authoring an org mode file with me. Please respond only with utf8 characters. No em-dashes. No sleek arrows. You always reply in a dry concise manner. As short as possible.

* Introduction
In order to have literate tests of the code in this project, since
some of the code operates in a buffer, we use =with-temp-buffer= to
simulate that.

* Scaffolding
#+begin_src emacs-lisp
  ;;; org-dialog.el --- Introduces executable PROMPT org blocks in org-mode -*- lexical-binding: t; -*-
  ;; Author: Pablo
  ;; Version: 0.1.0
  ;; Package-Requires: ((emacs "27.1") (org "9.0"))

  ;;; Code:
  (require 'org)
  (require 'org-element)
  (require 'json)
  (require 'url)
#+end_src

* Parsing org structure into prose/prompt/assistant sections
#+begin_src emacs-lisp
   (defun org-dialog--parse-blocks (pos)
     "Parse dialogue blocks from buffer start to POS.
   Returns ordered list of (TYPE . CONTENT) where TYPE is
   `prose', `prompt', or `assistant'.  Consecutive prose entries
   are merged.  Skips keywords and empty segments."
     (let* (;; 'greater-element granularity: identifies paragraphs, special
            ;; blocks, src blocks, example blocks - without recursing into
            ;; their contents (we extract raw text anyway).
            (tree (org-element-parse-buffer 'greater-element))
            ;; Walk tree in document order, collecting context elements.
            ;; org-element-map finds these at any depth (under headlines).
            ;; nil returns are filtered automatically.
            (raw (org-element-map tree '(paragraph special-block
                                         src-block example-block)
                   (lambda (el)
                     (when (<= (org-element-property :end el) pos)
                       (pcase (org-element-type el)
                         ;; Prose paragraph -> user context
                         ('paragraph
                          (let ((text (string-trim
                                       (buffer-substring-no-properties
                                        (org-element-property :begin el)
                                        (org-element-property :end el)))))
                            (when (> (length text) 0)
                              (cons 'prose text))))
                         ;; Source block -> user context, wrapped in markdown fence
                         ('src-block
                          (let ((lang (or (org-element-property :language el) ""))
                                (value (org-element-property :value el)))
                            (when (and value (> (length (string-trim value)) 0))
                              (cons 'prose
                                    (concat "```" lang "\n"
                                            (string-trim value)
                                            "\n```")))))
                         ;; Example block -> user context, wrapped in fence
                         ('example-block
                          (let ((value (org-element-property :value el)))
                            (when (and value (> (length (string-trim value)) 0))
                              (cons 'prose
                                    (concat "```\n"
                                            (string-trim value)
                                            "\n```")))))
                         ;; PROMPT or ASSISTANT special block
                         ('special-block
                          (let ((type-str (org-element-property :type el))
                                (cb (org-element-property :contents-begin el))
                                (ce (org-element-property :contents-end el)))
                            (when (member (upcase type-str) '("PROMPT" "ASSISTANT"))
                              (let ((content (and cb ce
                                                 (string-trim
                                                  (buffer-substring-no-properties cb ce)))))
                                (when (and content (> (length content) 0))
                                  (cons (if (string-equal-ignore-case type-str "PROMPT")
                                            'prompt 'assistant)
                                        content))))))))))))
       ;; Merge consecutive prose entries so multiple paragraphs and code
       ;; blocks between prompts become one user context message.
       (let ((merged nil))
         (dolist (entry raw)
           (if (and (eq (car entry) 'prose)
                    merged
                    (eq (car (car merged)) 'prose))
               ;; Previous entry was also prose - append with blank line
               (setcar merged (cons 'prose
                                    (concat (cdar merged) "\n\n" (cdr entry))))
             (push entry merged)))
         (nreverse merged))))
#+end_src

#+begin_src emacs-lisp :tangle no :wrap example :results value pp
    (with-temp-buffer
      (insert "#+TITLE: An example user of org-dialog
  This is an example collaboration between human and AI to author an .org
  document together.

  Interpersed within the prose of the document the human can write
  =#+begin_prompt= blocks, with some prompt to AI inside.

  The human then positions the pointer somewhere within the block and
  executes keychord ctrl-c ctrl-c, this sends the prompts to an AI, parses
  the AI's response and puts the response right after the prompt block,
  within a =#+begin_assistant= block.

  ,* Conversation

  ,#+begin_prompt
  What is 2 + 2?
  ,#+end_prompt

  ,#+begin_assistant
  2 + 2 = 4
  ,#+end_assistant

  ,#+begin_src python
  def add(a, b):
      return a + b
  ,#+end_src

  ,#+begin_prompt
  Multiply that by 5
  ,#+end_prompt")
      (org-dialog--parse-blocks (point-max)))
#+end_src

#+RESULTS:
#+begin_example
((prose
  . "This is an example collaboration between human and AI to author an .org\ndocument together.\n\nInterpersed within the prose of the document the human can write\n=#+begin_prompt= blocks, with some prompt to AI inside.\n\nThe human then positions the pointer somewhere within the block and\nexecutes keychord ctrl-c ctrl-c, this sends the prompts to an AI, parses\nthe AI's response and puts the response right after the prompt block,\nwithin a =#+begin_assistant= block.")

 (prompt . "What is 2 + 2?")

 (assistant . "2 + 2 = 4")

 (prose . "```python\ndef add(a, b):\n    return a + b\n```")

 (prompt . "Multiply that by 5"))
#+end_example

* Preparing LLM request
#+begin_src emacs-lisp
  (defun org-dialog--blocks-to-messages (blocks config)
    "Converts BLOCKS to OpenAI messages array.
  CONFIG is a plist with :system."
    (let ((messages nil)
  	(system (plist-get config :system)))
      (when system
        (push `((role . "system") (content . ,system)) messages))
      (dolist (block blocks)
        (let ((type (car block))
  	    (content (cdr block)))
  	(push `((role . ,(if (eq type 'assistant) "assistant" "user"))
  		(content . ,content))
  	      messages)))
      (nreverse messages)))
#+end_src

Example:

#+begin_src emacs-lisp :tangle no :wrap example :results value pp
  (let ((blocks '((prose . "This is an example collaboration between human and AI to author an .org\ndocument together.\n\nInterpersed within the prose of the document the human can write\n=#+begin_prompt= blocks, with some prompt to AI inside.\n\nThe human then positions the pointer somewhere within the block and\nexecutes keychord ctrl-c ctrl-c, this sends the prompts to an AI, parses\nthe AI's response and puts the response right after the prompt block,\nwithin a =#+begin_assistant= block.")
                  (prompt . "What is 2 + 2?")
                  (assistant . "2 + 2 = 4")
                  (prose . "```python\ndef add(a, b):\n    return a + b\n```")
                  (prompt . "Multiply that by 5"))))
    (org-dialog--blocks-to-messages blocks '(:system "You are a helpful assistant.")))
#+end_src

#+RESULTS:
#+begin_example
(((role . "system") (content . "You are a helpful assistant."))
 ((role . "user")
  (content
   . "This is an example collaboration between human and AI to author an .org\ndocument together.\n\nInterpersed within the prose of the document the human can write\n=#+begin_prompt= blocks, with some prompt to AI inside.\n\nThe human then positions the pointer somewhere within the block and\nexecutes keychord ctrl-c ctrl-c, this sends the prompts to an AI, parses\nthe AI's response and puts the response right after the prompt block,\nwithin a =#+begin_assistant= block."))
 ((role . "user") (content . "What is 2 + 2?"))
 ((role . "assistant") (content . "2 + 2 = 4"))
 ((role . "user")
  (content . "```python\ndef add(a, b):\n    return a + b\n```"))
 ((role . "user") (content . "Multiply that by 5")))
#+end_example

* Execute inference
#+begin_src emacs-lisp
  (defun org-dialog--infer (messages config callback error-callback)
    "Send MESSAGES to a Chat Completions endpoint.
  CONFIG is a plist with :endpoint :api-key :model.
  CALLBACK receives the response text.
  ERROR-CALLBACK receives an error string."
    (let* ((endpoint (plist-get config :endpoint))
           (api-key  (plist-get config :api-key))
           (model    (plist-get config :model))
           (url-request-method "POST")
           (url-request-extra-headers
            `(("Content-Type"  . "application/json")
              ("Authorization" . ,(concat "Bearer " api-key))))
           (url-request-data
            (encode-coding-string
             (json-serialize `((model . ,model)
                               (messages . ,(vconcat messages))))
             'utf-8)))
      (url-retrieve
       endpoint
       (lambda (status cb err-cb)
         (if (or (plist-get status :error)
                 (null url-http-end-of-headers))
             (funcall err-cb
                      (format "HTTP error: %s"
                              (or (plist-get status :error) "no response headers")))
           (goto-char url-http-end-of-headers)
           (condition-case e
               (let* ((json-object-type 'alist)
                      (json-array-type  'vector)
                      (resp (json-read))
                      (choices (alist-get 'choices resp))
                      (text (and choices
                                 (> (length choices) 0)
                                 (alist-get 'content
                                            (alist-get 'message
                                                       (aref choices 0))))))
                 (if text
                     (funcall cb text)
                   (funcall err-cb
                            (format "No content in response: %s"
                                    (buffer-substring (point) (point-max))))))
             (error
              (funcall err-cb
                       (format "JSON parse error: %s" e))))))
       (list callback error-callback) t)))
#+end_src

Sanity check - hits the endpoint synchronously:

#+begin_src emacs-lisp :tangle no :wrap example :results value pp :tangle no
  (let* ((url-request-method "POST")
         (url-request-extra-headers
          `(("Content-Type"  . "application/json")
            ("Authorization" . ,(concat "Bearer " (getenv "INFERENCE_API_KEY")))))
         (url-request-data
          (encode-coding-string
           (json-encode
            `((model . "gpt-5.2-chat")
              (messages . [((role . "user") (content . "What is 2 + 2?"))])))
           'utf-8))
         (buf (url-retrieve-synchronously
  	     "https://pablo-ml1b1csr-eastus2.cognitiveservices.azure.com/openai/v1/chat/completions")))
    (with-current-buffer buf
      (goto-char url-http-end-of-headers)
      (let* ((json-object-type 'alist)
             (json-array-type 'vector)
             (resp (json-read)))
        resp)))
#+end_src

#+RESULTS:
#+begin_example
((choices
  . [((content_filter_results
       (hate (filtered . :json-false) (severity . "safe"))
       (protected_material_code (filtered . :json-false)
				(detected . :json-false))
       (protected_material_text (filtered . :json-false)
				(detected . :json-false))
       (self_harm (filtered . :json-false) (severity . "safe"))
       (sexual (filtered . :json-false) (severity . "safe"))
       (violence (filtered . :json-false) (severity . "safe")))
      (finish_reason . "stop") (index . 0) (logprobs)
      (message (annotations . []) (content . "2 + 2 = **4**.")
	       (refusal) (role . "assistant")))])
 (created . 1770494705)
 (id . "chatcmpl-D6iq9PJjUpjckDcJ2bN4WmUWfVFNS")
 (model . "gpt-5.2-chat-2025-12-11") (object . "chat.completion")
 (prompt_filter_results
  . [((prompt_index . 0)
      (content_filter_results
       (hate (filtered . :json-false) (severity . "safe"))
       (jailbreak (filtered . :json-false) (detected . :json-false))
       (self_harm (filtered . :json-false) (severity . "safe"))
       (sexual (filtered . :json-false) (severity . "safe"))
       (violence (filtered . :json-false) (severity . "safe"))))])
 (system_fingerprint)
 (usage (completion_tokens . 19)
	(completion_tokens_details (accepted_prediction_tokens . 0)
				   (audio_tokens . 0)
				   (reasoning_tokens . 0)
				   (rejected_prediction_tokens . 0))
	(prompt_tokens . 14)
	(prompt_tokens_details (audio_tokens . 0) (cached_tokens . 0))
	(total_tokens . 33)))
#+end_example

* Escape org syntax in assistant responses
#+begin_src emacs-lisp
  (defun org-dialog--escape-org (text)
    "Comma-escape lines in TEXT that org would interpret as structure.
  Escapes lines starting with `*' (headings) or `#+' (keywords/blocks)."
    (replace-regexp-in-string
     "^\\(\\*\\|#\\+\\)" ",\\1" text))
#+end_src

* Execute a PROMPT block
#+begin_src emacs-lisp
  (defun org-dialog-execute ()
    "Send the current prompt block to inference endpoint and insert the response."
    (interactive)
    (let ((bounds (org-dialog--in-prompt-p)))
      (unless bounds
        (user-error "Not inside a #+BEGIN_PROMPT block"))
      (let* ((prompt-end (cdr bounds))
  	   (config (org-dialog--config))
  	   (blocks (org-dialog--parse-blocks prompt-end))
  	   (messages (org-dialog--blocks-to-messages blocks config))
  	   (buf (current-buffer))
  	   (inhibit-read-only t))
        ;; Set read-only
        (setq buffer-read-only t)
        (message "org-dialog: inferring...")
        (funcall #'org-dialog--infer
  	       messages config
  	       (lambda (text)
  		 (with-current-buffer buf
  		   (let ((inhibit-read-only t))
  		     (save-excursion
  		       (goto-char prompt-end)
  		       (let ((case-fold-search t)
  			     (insert-at nil))
  			 ;; Check for existing assistant block immediately after
  			 (save-excursion
  			   (forward-line 1)
  			   (skip-chars-forward " \t\n")
  			   (when (looking-at "^[\t]*#\\+begin_assistant")
  			     (setq insert-at (point))))
  			 (if insert-at
  			     ;; replace content of existing assistant block
  			     (progn
  			       (goto-char insert-at)
  			       (forward-line 1)
  			       (let ((content-start (point)))
  				 (re-search-forward "^[ \t]*#\\+end_assistant")
  				 (delete-region content-start (line-beginning-position))
  				 (goto-char content-start)
  				 (insert (org-dialog--escape-org text) "\n")))
  			   ;; Insert new assistant block
  			   (goto-char prompt-end)
  			   (end-of-line)
  			   (insert "\n\n#+begin_assistant\n"
  				   (org-dialog--escape-org text)
  				   "\n#+end_assistant"))))
  		     ; (org-dialog--apply-overlays)
  		     (org-dialog--apply-overlays)
  		     (setq buffer-read-only nil)
  		     (message "org-dialog: done."))))
  	       ;; Error callback
  	       (lambda (err)
  		 (with-current-buffer buf
  		   (let ((inhibit-read-only t))
  		     (setq buffer-read-only nil))
  		   (message "org-dialog error: %s" err)))))))
#+end_src

* Utilities
** Get settings from org file header
#+begin_src emacs-lisp
  ;;; Config
  (defun org-dialog--keyword (key)
    "Read a #+KEY: value from the current org buffer."
    (cadr (assoc key (org-collect-keywords (list key)))))
#+end_src

Example - can retrieve the model.

#+begin_src emacs-lisp :tangle no :wrap example :results value pp 
  (with-temp-buffer
    (insert "#+TITLE: An org dialog file\n#+DIALOG_MODEL: gpt-5.2-chat")
    (org-dialog--keyword "DIALOG_MODEL"))
#+end_src

#+RESULTS:
#+begin_example
"gpt-5.2-chat"
#+end_example

** Gather all settings
#+begin_src emacs-lisp
  (defun org-dialog--config ()
    "Compose dialog config from buffer keywords.
  Returns plist (:model :endpoint :api-key :system)."
    (let* ((model (org-dialog--keyword "DIALOG_MODEL"))
  	 (endpoint (org-dialog--keyword "DIALOG_ENDPOINT"))
  	 (api-key-env (org-dialog--keyword "DIALOG_API_KEY"))
  	 (api-key (getenv api-key-env))
  	 (system (org-dialog--keyword "DIALOG_SYSTEM")))
      (unless model (user-error "No #+DIALOG_MODEL: set"))
      (unless endpoint (user-error "No #+DIALOG_ENDPOINT: set"))
      (unless api-key (user-error "No #+DIALOG_API_KEY: set"))

      (list :model model :endpoint endpoint :api-key api-key :system system)))
#+end_src

Example -- all settings read and returned.

#+begin_src emacs-lisp :tangle no :wrap example :results value pp
  (with-temp-buffer
    (org-mode)
    (setq-local process-environment (cons "MY_API_KEY=abc123" process-environment))
    (insert "#+TITLE: An example org dialog
  ,#+DIALOG_MODEL: gpt-5.2-chat
  ,#+DIALOG_ENDPOINT: https://foo.bar/v1/completions
  ,#+DIALOG_API_KEY: MY_API_KEY
  ,#+DIALOG_SYSTEM: You are a helpful assistant co-writing an org mode file with me

  ,* Introduction
  The goal of this dialog is to...
  ")
    (org-dialog--config))
#+end_src

#+RESULTS:
#+begin_example
  (:model "gpt-5.2-chat"
   :endpoint "https://foo.bar/v1/completions"
   :api-key "abc123"
   :system "You are a helpful assistant co-writing an org mode file with me")
#+end_example

** Detect if pointer on prompt block
#+begin_src emacs-lisp
  ;;; Block detection
  (defun org-dialog--in-prompt-p ()
      "Return (BEG . END) if point is inside a #+begin_prompt block, nil otherwise.
  BEG is the start of #+begin_prompt line, END is the end of #+end_prompt line."
    (save-excursion
      (let ((pos (point))
  	  (case-fold-search t))
        (when (re-search-backward "^[ \t]*#\\+begin_prompt" nil t)
  	(let ((beg (line-beginning-position)))
  	  (when (re-search-forward "^[ \t]*#\\+end_prompt" nil t)
  	    (let ((end (line-end-position)))
  	      (when ( <= pos end)
  		(cons beg end)))))))))
#+end_src

Example - can detect whether point is at a prompt block or not:

#+begin_src emacs-lisp :tangle no :wrap example :results output
    (with-temp-buffer
      (org-mode)
      (insert "* A heading
  ,#+begin_prompt
  How old is earth
  ,#+end_prompt")
      (princ (format "In prompt: %s\n" (org-dialog--in-prompt-p)))
      (insert "
  Some more different text")
      (princ (format "In prompt: %s" (org-dialog--in-prompt-p))))
#+end_src

#+RESULTS:
#+begin_example
In prompt: (13 . 57)
In prompt: nil
#+end_example

* User experience Look and feel
** Different color for assisant block content
#+begin_src emacs-lisp
(defface org-dialog-assistant
  '((((background dark))
     :foreground "#88c0d0" :slant italic :extend t)
    (((background light))
     :foreground "#3465a4" :slant italic :extend t))
  "Face for assistant block content."
  :group 'org-dialog)
#+end_src

** Apply overlays (face, indent)
#+begin_src emacs-lisp
(defun org-dialog--apply-overlays ()
  "Apply face overlays to all assistant block contents in the buffer."
  (remove-overlays (point-min) (point-max) 'org-dialog-assistant t)
  (save-excursion
    (goto-char (point-min))
    (let ((case-fold-search t))
      (while (re-search-forward "^[ \t]*#\\+BEGIN_ASSISTANT" nil t)
        (let ((content-start (progn (forward-line 1) (point))))
          (when (re-search-forward "^[ \t]*#\\+END_ASSISTANT" nil t)
            (let* ((content-end (line-beginning-position))
                   (ov (make-overlay content-start content-end nil t nil)))
              (overlay-put ov 'org-dialog-assistant t)
              (overlay-put ov 'face 'org-dialog-assistant)
              (overlay-put ov 'line-prefix "  ")
              (overlay-put ov 'wrap-prefix "  "))))))))
#+end_src

** Keybindings
#+begin_src emacs-lisp
;;; C-c C-c hook

(defun org-dialog--ctrl-c-ctrl-c ()
  "Hook for `org-ctrl-c-ctrl-c-hook'.
If point is inside a prompt block, execute it and return t."
  (when (org-dialog--in-prompt-p)
    (org-dialog-execute)
    t))
#+end_src

* Footer
#+begin_src emacs-lisp
  ;;; Minor mode

  ;;;###autoload
  (define-minor-mode org-dialog-mode
    "Minor mode for LLM dialog notebooks in org-mode.
  Intercepts C-c C-c inside #+BEGIN_PROMPT blocks to send
  conversation history to an LLM and insert the response."
    :lighter " Dia"
    :group 'org-dialog
    (if org-dialog-mode
        (progn
          (add-hook 'org-ctrl-c-ctrl-c-hook
                    #'org-dialog--ctrl-c-ctrl-c nil t)
          (org-dialog--apply-overlays))
      (remove-hook 'org-ctrl-c-ctrl-c-hook
                   #'org-dialog--ctrl-c-ctrl-c t)
      (remove-overlays (point-min) (point-max) 'org-dialog-assistant t)))

    (provide 'org-dialog)
    ;;; org-dialog.el ends here
#+end_src

* Exploration

#+begin_prompt
What do you think of this project?
#+end_prompt

#+begin_assistant
Notes.

- Overall structure is coherent. Literate tests with with-temp-buffer are appropriate.
- org-dialog--parse-blocks is the most complex part. Add unit tests for mixed nesting and headlines.
- Keyword error typo: "No #+DIAG_MODEL:" should be "DIALOG_MODEL".
- org-dialog--infer uses chat completions schema. Works for current endpoint but is brittle.
- org-dialog-execute sets buffer-read-only twice. Simplify with unwind-protect.
- org-dialog--escape-org should also handle leading commas already present.
- Overlay application is correct but O(n) on whole buffer each run.
- Consider making org-dialog--blocks-to-messages treat prose before first prompt as system or user explicitly.
#+end_assistant

#+begin_prompt
give me an improved version of the TOC (what you would name each section)
#+end_prompt

#+begin_assistant
Solid project.

- Clear goal and good org integration.
- Parsing approach is reasonable and testable.
- Literate tests are well done.
- Code is readable and idiomatic.

Concerns.

- parse-blocks complexity and edge cases need more tests.
- Inference layer is tightly coupled to one API shape.
- Error handling and read-only toggling need cleanup.
- Performance may degrade on large buffers.

Overall: promising, usable, needs hardening.
#+end_assistant
